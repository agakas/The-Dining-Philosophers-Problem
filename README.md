# The Dining Philosophers Problem (C++11, CMake)

Решение классической задачи об обедающих философах с использованием средств стандартной библиотеки C++ (не ниже C++11).

Решение:
- не допускает deadlock
- корректно завершает работу всех потоков
- использует только стандартную библиотеку C++
- собирается с помощью CMake на macOS и Windows

---

## Используемые технологии

- C++11
- CMake (out-of-source build)
- Стандартная библиотека C++

Сторонние библиотеки **не используются**.

---

## Идея алгоритма

Решение основано на **атомарном захвате обоих ресурсов** для предотвращения блокировки (deadlock). Ключевые принципы:

### 1. Единая точка синхронизации
Все операции с вилками (`take_forks` / `put_forks`) защищены одним мьютексом. Состояние каждой вилки хранится в векторе `forks_` (`true` — свободна, `false` — занята).

### 2. Ожидание обеих вилок
Философ никогда не берёт вилки по отдельности. Он ожидает через `std::condition_variable`, пока **обе** соседние вилки (левая `id` и правая `(id + 1) % N`) одновременно не станут свободны

```cpp
cv_.wait(lock, [&] { 
    return stop_ || (forks_[id] && forks_[(id + 1) % count_]);
});
```

Только после этого атомарно захватывает обе вилки. Это исключает классический сценарий deadlock, когда все философы одновременно берут левую вилку и блокируют друг друга при попытке взять правую.

### 3. Симметричная логика для всех потоков
В отличие от решений с иерархией ресурсов (например, «нечётные философы берут левую вилку первыми»), здесь все потоки следуют единому алгоритму. Это упрощает реализацию и делает поведение системы предсказуемым.

### 4.Корректное завершение
Флаг stop_ позволяет мгновенно прервать ожидание всех философов при завершении программы. Вызов cv_.notify_all() в stop() гарантирует, что все потоки выйдут из wait() и корректно завершатся через join()

---

## Структура проекта

```
.
├── CMakeLists.txt
├── src/
│   ├── main.cpp
│   ├── philosopher.h
│   ├── philosopher.cpp
│   ├── table.h
│   ├── table.cpp
│   ├── logger.h
│   └── logger.cpp
└── README.md
```

Сборка выполняется вне дерева исходников (`build/` не сохранен в репозитории).

---

## Сборка и запуск

### macOS (мастер-система)

```bash
cmake -S . -B build
cmake --build build
./build/philosophers
```

---

### Windows

```powershell
cmake -S . -B build -G "Visual Studio 18 2026" -A x64
cmake --build build --config Release
.\build\Release\philosophers.exe
```

Для сборки под Windows были необходимы инструменты разработчика Microsoft Visual Studio 2026.

---

## Логирование

Во время работы программа выводит информацию о действиях философов в стандартный вывод в формате:

```
[TID][HH:MM:SS:ms] Philosopher N (action)
```

Пример:

```
[TID 0x16fb9b000] [23:18:17:649] Philosopher 4 began to think
[TID 0x16fb0f000] [23:18:17:645] Philosopher 3 finished thinking
[TID 2772] [23:18:17:652] Philosopher 2 took the forks
```

Логирование потокобезопасно.

---

## Завершение программы

Программа корректно завершает работу:
- главный поток инициирует остановку
- все философы завершают свои циклы
- все потоки корректно `join()`-ятся

Бесконечно работающих потоков нет.